### 刷题心得
#### 1、如何通过字典的value来访问key
##### 现有博客中介绍过很多实现方法，但是大多数都要求value值必须唯一，真实情况下的实用性太差，这里记录一个简单实用的思路：即构建一个新的字典进行键值的反转，但由于无法保证value值的唯一性，因此新字典中的每个键对应的值需要为一个列表。关键代码如下：
```python
    for key,value in hash.items():
        if value in frequent:
            frequent[value].append(key)
        else:
            frequent[value] = [key]
```
##### 典型题目为桶排序的「347. 前k个高频元素」和「451. 根据字符出现频率排序」

#### 2、同时获取数组元素出现频率和子序列长度的方法
##### 用一个字典同时存储给定数组的数值及相应数值所在的下标和个数，如下格式：{数值1：[下标1，下标2，...，下标m]}，即{数值：下标列表}的方法来存储，这样既可以获取某数值的范围，也可以通过len()的方法获取特定数值在数组中出现的次数，一举两得。关键代码如下：
```python
    for i,v in enumerate(nums):
        if v in dic:
            dic[v].append(i)
        else:
            dic[v] = [i]
    degree = max(len(i) for i in dic.values())
```
##### 典型题目为「697. 数组的度」

#### 3、在存储临时判别元素时，尽量用字典或集合，不要用列表、元组和字符串，因为集合和字典的存取时间复杂度为O（1），查询效率更高。此外在查询速度和内存占用方面，列表与字典的区别如下：
- 字典的查询速度永远都是O(1)，速度不会随字典内元素的增加而改变，但是字典的缺点是占用内存过大；
- 列表的查询速度为O(N)，因此列表内元素越多，查询速度越慢，但是列表的优点是占用内存小。


### 需要时常回顾的难题：
#### String
- 242.有效的字母异位词（简单题，**ord()函数**的作用就是**获取字符对应的ASCII数值**）
- 696.计数二进制子串
- 647.回文子串
#### Linked List
- 83.删除排序链表中的重复元素（递归实现）
- 725.分隔链表（循环条件需要记住）
#### Stack and Queue
- 20.有效的括号（循环中的判断条件要先if判断栈不为空且c在字典中，再弹出元素用if进行比较）
#### Hash Table
- 594.最长和谐子序列（可以使用for v in hashmap的方法遍历字典，并且用if语句去判断v+1是否在hashmap中）
- 128.最长连续序列
#### Array and Matrix
- 378.有序矩阵中第-k-小的元素（二分查找在矩阵中的应用）
- 287.寻找重复数（二分查找在列表中的应用，较难）
- 667.优美的排列-ii（等差数列的性质）
- 769.最多能完成排序的块（已遍历元素最大值 == 当前下标）
#### Bit Manipulation
- 260.只出现一次的数字-iii（很经典的位运算综合题目）
- 190.颠倒二进制位（无符号左移右移经典题目）
- 371.两整数之和（递归，异或，与，左移）
- 318.最大单词长度乘积（或，左移）
#### Two Pointers
- 680.验证回文字符串-ⅱ
#### Sort
- ALL
#### Math
- ALL

