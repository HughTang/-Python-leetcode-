# 查找

## 一、静态查找表
​        静态查找表主要满足一下两点：

    a.查找某个“特定的”数据元素是否在查找表中；
    
    b.检索某个“特定的”数据元素的各种属性。

| 方法         | 特点                                     | 时间复杂度 |
| ------------ | ---------------------------------------- | ---------- |
| 顺序查找     | 逐个比较，等概率比较                     | O(n)       |
| 二分查找     | 前提是序列有序                           | O(logn)    |
| 次优查找     | 不等概率，优先查找概率大的               | -          |
| 索引顺序查找 | 分块有序；二分查找确定分块，块内顺序查找 | -          |

## 二、动态查找表

动态查找表相比于静态查找表有两个不同的特点：

​    a.在查找表中查询一个数据元素，如果不存在则插入查找表中；

​    b.从查找表中删去某个数据元素。

### 1.二叉排序树

### 2.平衡二叉树

### 3.B-树

### 4.B+树



## 三、哈希

### 1.哈希表

### 2.哈希函数(杂凑函数)
​        常见的构造哈希函数的方法有：

**(1)直接定址法**
        取关键字或关键字的某个线性函数值为哈希地址。即H(key)=key或H(key)=a*key+b，其中a、b为常数。

**(2)数字分析法**
        假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是实现知道，即可取关键字的若干数位组成哈希地址。

**(3)平方取中法**
        取关键字平方后的中间几位为哈希地址。

**(4)除留取余法**
        去关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址，即H(key)= key MOD p, p<=m。

 ### 3.处理冲突的方法
#### (1)开放定址法

a.线性探测再散列

b.二次探测再散列

c.伪随机探测再散列



#### (2)再哈希法
​        即在同义词(具有相同函数值的关键字对同一个函数而言为同义词)产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。



#### (3)链地址法
​        将所有关键字为同义词的记录存储在同一线性链表中。





# 排序

| 排序法     | 最差时间分析 | 平均时间复杂度 | 稳定度 | 空间复杂度 |
| ---------- | ------------ | -------------- | ------ | ---------- |
| 冒泡排序   | O(n^2)       | O(n^2)         | 稳定   | O(1)       |
| 快速排序   | O(n^2)       | O(n*logn)      | 不稳定 | O(logn)    |
| 选择排序   | O(n^2)       | O(n^2)         | 稳定   | O(1)       |
| 归并排序   | O(n*logn)    | O(n*logn)      | 不稳定 | O(n)       |
| 二叉树排序 | O(n^2)       | O(n*logn)      | 不一顶 | O(n)       |
| 插入排序   | O(n^2)       | O(n^2)         | 稳定   | O(1)       |
| 堆排序     | O(n*logn)    | O(n*logn)      | 不稳定 | O(1)       |
| 希尔排序   | O            | O              | 不稳定 | O(1)       |
| 桶排序     | O(n^2)       | O(n+k)         | 稳定   | O(n+k)     |
| 基数排序   | O(n*k)       | O(n*k)         | 稳定   | O(n+k)     |

k:桶的个数

|       算法       | 稳定性 |          时间复杂度          | 空间复杂度 |           备注           |
| :--------------: | :----: | :--------------------------: | :--------: | :----------------------: |
|     选择排序     |   ×    |              N2              |     1      |                          |
|     冒泡排序     |   √    |              N2              |     1      |                          |
|     插入排序     |   √    |            N ~ N2            |     1      | 时间复杂度和初始顺序有关 |
|     希尔排序     |   ×    | N 的若干倍乘于递增序列的长度 |     1      |      改进版插入排序      |
|     快速排序     |   ×    |            NlogN             |    logN    |                          |
| 三向切分快速排序 |   ×    |          N ~ NlogN           |    logN    |   适用于有大量重复主键   |
|     归并排序     |   √    |            NlogN             |     N      |                          |
|      堆排序      |   ×    |            NlogN             |     1      |    无法利用局部性原理    |





# 常见数据结构

## 二叉查找树

**二叉查找树** （BST）是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值。

BST 有一个重要性质，就是它的中序遍历结果递增排序。



## 2-3 查找树

2-3 查找树引入了 2- 节点和 3- 节点，目的是为了让树平衡。一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的。

### 1. 插入操作

插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。

根据叶子节点的类型不同，有不同的处理方式：

- 如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。

![](https://i.loli.net/2021/03/30/7EJeOZ34VLWgdAR.jpg)

- 如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。

![](https://i.loli.net/2021/03/30/8IgH6d5epNByGCO.jpg)

### 2. 性质

2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。

2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。



## 红黑树

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**

从性质5又可以推出：

- 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点

一颗简单的红黑树。其中Nil为叶子结点(**图中的红色结点H和M同样存在叶子子结点，后文的图类似，不再阐明。**)，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)

 ![img](https://upload-images.jianshu.io/upload_images/2392382-4996bbfb4017a3b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)

**图1 一颗简单的红黑树**

红黑树并不是一个*完美*平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为**黑色完美平衡**。

约定下红黑树一些结点的叫法：

![img](https://upload-images.jianshu.io/upload_images/2392382-abedf3ecc733ccd5.png?imageMogr2/auto-orient/strip|imageView2/2/w/772/format/webp)

**图2 结点叫法约定**

红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。

- **左旋**：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。
- **右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。
- **变色**：结点的颜色由红变黑或由黑变红。

![img](https://upload-images.jianshu.io/upload_images/2392382-a95db442f1b47f8a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**图3 左旋**

![img](https://upload-images.jianshu.io/upload_images/2392382-0676a8e2a12e2a0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**图4 右旋**

上面所说的旋转结点也即旋转的支点，图4和图5中的P结点。
 我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。
 **左旋**只影响旋转结点和其**右子树**的结构，把右子树的结点往左子树挪了。
 **右旋**只影响旋转结点和其**左子树**的结构，把左子树的结点往右子树挪了。

所以旋转操作是**局部**的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。

但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住**红黑树总是通过旋转和变色达到自平衡**。



### 红黑树查找

因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：

1. 从根结点开始查找，把根结点设置为当前结点；
2. 若当前结点为空，返回null；
3. 若当前结点不为空，用当前结点的key跟查找key作比较；
4. 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
5. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
6. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；

![img](https://upload-images.jianshu.io/upload_images/2392382-07b47eb3722981e6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

它的查找最坏时间复杂度为**O(2lgN)**，也即整颗树刚好红黑相隔的时候。

### 红黑树插入

插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：

1. 从根结点开始查找；
2. 若根结点为空，那么插入结点作为根结点，结束。
3. 若根结点不为空，那么把根结点作为当前结点；
4. 若当前结点为null，返回当前结点的父结点，结束。
5. 若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。
6. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；
7. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；

![img](https://upload-images.jianshu.io/upload_images/2392382-7521866b50683a24.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

插入结点是应该是什么颜色呢？答案是**红色**。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。

所有插入情景如下图

![img](https://upload-images.jianshu.io/upload_images/2392382-fa2b78271263d2c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1033/format/webp)

根据二叉树的性质，**除了情景2，所有插入操作都是在叶子结点进行的**。因为查找插入位置时，我们就是在找子结点为空的父结点的。

约定如下图：

![img](https://upload-images.jianshu.io/upload_images/2392382-9ac3d6b69ef7ead3.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)







### 使用场景
**红黑树多用于搜索,插入,删除操作多的情况下**
**红黑树应用比较广泛：**
**1. 广泛用在`C++`的`STL`中。`map`和`set`都是用红黑树实现的。**
**2. 著名的`linux`进程调度`Completely Fair Scheduler`,用红黑树管理进程控制块。**
**3.`epoll`在内核中的实现，用红黑树管理事件块**
**4.`nginx`中，用红黑树管理`timer`等**



## **B-tree（B-树或者B树）**

一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：
1、根结点至少有两个子女；
2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；
3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故**内部子树**个数 k 满足：┌m/2┐ <= k <= m ；
4、所有的叶子结点都位于同一层。

B树(B-Tree)是一种自平衡的树,它是一种多路搜索树（并不是二叉的），能够保证数据有序。同时它还保证了在查找、插入、删除等操作时性能都能保持在`O(logn)`，为大块数据的读写操作做了优化,同时它也可以用来描述外部存储(支持对保存在磁盘或者网络上的符号表进行外部查找)

## **B+树**

B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:
(1)每个结点至多有m个子女；
(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；
(3)有k个子女的结点必有k个关键字。
B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。

**更适合文件索引系统**
**原因： 增删文件（节点）时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率**
**使用场景：**
**文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：**
**Windows：HPFS 文件系统**
**Mac：HFS，HFS+ 文件系统**
**Linux：ResiserFS，XFS，Ext3FS，JFS 文件系统**
**数据库：ORACLE，MYSQL，SQLSERVER 等中**
**B树：有序数组+平衡多叉树**
**B+树：有序数组链表+平衡多叉树**



