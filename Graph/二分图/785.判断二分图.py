#
# @lc app=leetcode.cn id=785 lang=python3
#
# [785] 判断二分图
#

# @lc code=start
# 使用染色法
# 对于图中的任意两个节点u和v，如果它们之间有一条边直接相连，那么u和v必须属于不同的集合。
# 如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成红色。随后我们对整个图进行遍历，将该节点直接相连的所有节点染成绿色，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，直到无向图中的每个节点均被染色。
# 如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同，也就说明这个无向图不是一个二分图。
# 算法的流程如下：
# （1）我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；
# （2）在遍历的过程中，如果我们通过节点u遍历到了节点v（即u和v在图中有一条边直接相连），那么会有两种情况：
#      ①如果v未被染色，那么我们将其染成与u不同的颜色，并对v直接相连的节点进行遍历；
#      ②如果v被染色，并且颜色与u相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回False作为答案。
# （3）当遍历结束时，说明给定的无向图是二分图，返回True作为答案。
# 下面的代码中，color代表每个下标元素的颜色，未染色为-1，红色为0，绿色为1。
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        # 将所有节点颜色初始化为-1（未染色）
        color = [-1] * len(graph)
        # 遍历每个节点并包含非连通图的情况
        for i in range(len(graph)):
            # 如果当前节点未染色并且与之直接相连和间接相连的节点存在染色冲突的情况，则说明该图不是二分图，直接返回False
            if color[i] == -1 and not self.dfs(i, 0, color, graph):
                return False
        # 如果所有节点完成染色并且与之直接相连和间接相连的节点全部染色成功，则说明该图是二分图，返回True
        return True

    # 深度优先遍历并对递归地对节点进行染色，传入的参数依次为当前节点值、当前节点要染的颜色、节点颜色集合、给定的图
    def dfs(self, curNode: int, curColor: int, color: List[int], graph: List[List[int]]) -> bool:
        # 如果当前节点之前已经染色过，则判断之前染的颜色与要染的颜色是否一致，一致返回True，不一致返回False
        if color[curNode] != -1:
            return color[curNode] == curColor
        # 当前节点未染色，则将其染为给定的颜色
        color[curNode] = curColor
        # 从当前节点开始进行深度优先搜索
        for v in graph[curNode]:
            # 如果在染色过程中存在之前染的颜色与要染的颜色不一致的情况，则返回False
            if not self.dfs(v, 1-curColor, color, graph):
                return False
        # 如果当前子连通图中所有节点完成染色并且与之直接相连和间接相连的节点全部染色成功，则说明该子连通图是二分图，返回True
        return True
# @lc code=end

