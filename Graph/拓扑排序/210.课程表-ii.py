#
# @lc app=leetcode.cn id=210 lang=python3
#
# [210] 课程表 II
#

# @lc code=start
# 
# 本题是一道经典的「拓扑排序」问题。
# 
# 给定一个包含n个节点的有向图G，我们给出它的节点编号的一种排列，如果满足：对于图G中的任意一条有向边 (u, v)，u在排列中都出现在v的前面。
# 那么称该排列是图G的「拓扑排序」。根据上述的定义，我们可以得出两个结论：
# 
# （1）如果图G中存在环（即图G不是「有向无环图」），那么图G不存在拓扑排序。这是因为假设图中存在环x1,x2,...,xn,x1。那么x1在排列中必须
# 出现在xn的前面，但xn同时也必须出现在x1的前面，因此不存在一个满足要求的排列，也就不存在拓扑排序；
# （2）如果图G是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图G只包含n个节点却没有任何边，那么任意一种编号的排列
# 都可以作为拓扑排序。
# 
# 有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：
# 
# （1）我们将每一门课看成一个节点；
# （2）如果想要学习课程A之前必须完成课程B，那么我们从B到A连接一条有向边。这样一来，在拓扑排序中，B一定出现在A的前面。
# 
# 求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。求解拓扑排序的方法主要有两种，分别是深度优先搜索（DFS）和广度优先搜索（BFS），
# 两种方法的性能是相同的，因此掌握一种即可。下面主要介绍的是「深度优先搜索」的方法，该方法的代码比较容易理解。
# 
# 
# 对于图中的任意一个节点，可以用visit列表来存储每个节点的搜索状态，它在搜索过程中有三种状态，即：
#
# 「未搜索」：我们还没有搜索到这个节点，用0表示；
# 「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成，用-1表示；
# 「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求，用1表示。
# 
# 通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，这里采用逆邻接表graph来存储每个节点的前驱结点，在每一轮的搜索开始时，
# 我们任取一个「未搜索」的节点（visit[i]==0）开始进行深度优先搜索。我们将当前搜索的节点u标记为「搜索中」，遍历该节点的每一个相邻节点v：

# （1）如果v为「未搜索」，那么我们开始递归搜索v，待搜索完成回溯到u；
# （2）如果v为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；
# （3）如果v为「已完成」，那么说明v已经在栈中了，而u还不在栈中，因此u无论何时入栈都不会影响到 (u, v)之前的拓扑关系，因此不用进行任何操作。
# 
# 当u搜索到入度为0的节点v时，我们将v放入栈中，并将其标记为「已完成」。
#
# 在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的n个节点，从栈底到栈顶的顺序即为一种拓扑排序。
# 
# 通俗点的算法流程如下：
# 第 1 步：构建逆邻接表graph、访问列表visit和结果栈ans；
# 第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。
# 第 3 步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。
# 第 4 步：将最后的结果栈ans返回。
#
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        # 初始化逆邻接表
        graph = [[] for _ in range(numCourses)]
        # 初始化节点访问列表visit，0表示未访问，-1表示正在访问，1表示已访问
        visit = [0] * numCourses
        # 初始化结果栈ans
        ans = list()
        # 将每个节点及其前驱结点加入到graph中
        for x, y in prerequisites:
            graph[x].append(y)
        # 对每个未访问节点进行深度优先搜索
        for i in range(numCourses):
            if visit[i] == 0 and not self.dfs(i, visit, graph, ans):
                return []
        # 返回结果栈ans
        return ans

    # 深度优先搜索函数
    def dfs(self, i: int, visit: List[int], graph: List[List[int]], ans: List[int]) -> bool:
        # 如果节点i的visit[i]的值为-1，即搜索中，则说明该有向图存在环，返回False
        if visit[i] == -1:
            return False
        # 如果节点i的visit[i]的值为1，即已搜索，则直接返回True
        elif visit[i] == 1:
            return True
        # 如果节点i的visit[i]的值为0，即未搜索，则将其状态改为-1，即搜索中
        visit[i] = -1
        # 对节点i的前驱结点列表进行递归遍历，如果在递归过程中出现环，则返回False
        for j in graph[i]:
            if not self.dfs(j, visit, graph, ans):
                return False
        # 将当前节点i的visit[i]的值改为1，表示已搜索
        visit[i] = 1
        # 将当前节点i入栈
        ans.append(i)
        # 该轮深度优先搜索结束，返回True
        return True
# @lc code=end

