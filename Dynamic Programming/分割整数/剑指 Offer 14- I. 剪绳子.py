#
# @lc app=leetcode.cn id=1 lang=python
#
# 剑指 Offer 14- I. 剪绳子
#
# 问题描述：
# 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
# 每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
# 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
# 
# leetcode网址：
# https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
# 
# 题解思路：
# 尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度
# 为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。
# 
# 将绳子拆成 1 和 n-1，则 1(n-1)-n=-1<0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。
# 将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n>=4 时这样拆开能得到的乘积会比不拆更大。
# 将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n>=5 时效果更好。
# 将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。
# 将绳子拆成 5 和 n-5，因为 5=2+3，而 5<2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。
# 将绳子拆成 6 和 n-6，因为 6=3+3，而 6<3*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 >= 0，在 n>=5 的情况下将绳子拆成 3 比拆成 2 效果更好。
# 
# 继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，
# 当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。

class Solution:
    # 贪心算法
    # 时间复杂度和空间复杂度都是O(1)
    def cuttingRope(self, n: int) -> int:
        if n <= 3: 
            return n - 1
        ans = 1
        while n > 4:
            ans *= 3
            n -= 3
        # 当n<=4时，不再做分割便是最优的结果
        return ans * n

    # 动态规划
    # 时间复杂度为O(N²)，空间复杂度为O(N)
    def cuttingRope(self, n: int) -> int:
        dp = [0] * (n + 1)
        for i in range(2, n + 1):
            # 对长度为i的绳子, 在j处的切割后, 接下来有两种选择:
            # （1）继续切(i - j)长度的绳子, 则ans = dp[i - j] * j
            # （2）不切了, 则ans = (i - j) * j
            # 由于切j和切i-j的效果是一样的，所以嵌套循环中的条件设置为i//2+1即可
            for j in range(1, i//2 + 1):
                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
        return dp[n]
# @lc code=start