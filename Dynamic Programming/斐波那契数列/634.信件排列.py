# 题目描述
# NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发邮件，
# 在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？

# 解题思路
# 定义一个数组dp表示存储错误方式数量，dp[n]表示n个邮件和人的错误发送数量。把第n封信放在第k个信箱中，那么第k封信的放置就有以下两种情况：
# （1）第k封信放到信箱n中，那么剩下n-2封信和n-2个信箱就有dp[n-2]种放法，而由于k的取值有n-1种，所以该情况下共有(n-1)*dp[n-2]中错误装信方式；
# （2）第k封信不放到信箱n中，那么剩下包括第k封信在内的n-1封信和包括第n个信箱在内的n-1个信箱，由于第k封信不能放到信箱n中，所以我们可以把信箱n
# 作为信封k的“专属信箱”（“正确信箱”），那么剩下n-1封信和n-1个信箱就有dp[n-1]种放法，而由于k的取值同样有n-1种，所以该情况下共有(n-1)*dp[n-1]
# 种错误装信方式；

# 状态转移方程（将思路中的n换成i即可）
# dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1]

# @lc code=start
class Solution:
    # 空间复杂度为O(N)
    def errorNum(self, n: int) -> int:
        if n == 0 or n == 1:
            return 0
        dp = [0] * n
        # 这里的dp[1]表示2个信箱和信封的情况
        dp[0], dp[1] = 0, 1
        for i in range(2,n):
            dp[i] = (i-1) * dp[i-2] + (i-1) * dp[i-1]
        return dp[-1]
    
    # 空间复杂度为O(1)
    def errorNum(self, n: int) -> int:
        if n == 0 or n == 1:
            return 0
        a, b = 0, 1
        for i in range(2,n):
            b, a = (i-1) * a + (i-1) * b, b
        return b
# @lc code=end