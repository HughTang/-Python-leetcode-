#
# @lc app=leetcode.cn id=1143 lang=python3
#
# [1143] 最长公共子序列
#

# @lc code=start
class Solution:
    # 二维动态规划问题
    # 解题思路：
    # 首先，区分两个概念：子序列可以是不连续的；子数组（子字符串）需要是连续的；
    # 另外，动态规划也是有套路的：单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i][j] ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。
    #
    # 状态定义：
    # 定义 dp[i][j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。 （注：text1[0:i-1] 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含）
    # 之所以 dp[i][j] 的定义不是 text1[0:i] 和 text2[0:j] ，是为了方便当 i = 0 或者 j = 0 的时候，dp[i][j]表示的为空字符串和另外一个字符串的匹配，这样 dp[i][j] 可以初始化为 0.
    #
    # 状态转移方程：
    # （1）当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i][j] = dp[i - 1][j - 1] + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。
    # （2）当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dp[i][j] 应该是 dp[i - 1][j] 和 dp[i][j - 1] 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。
    # 
    # 状态的初始化：
    # 初始化就是要看当 i = 0 与 j = 0 时， dp[i][j] 应该取值为多少。
    # （1）当 i = 0 时，dp[0][j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0.
    # （2）当 j = 0 时，dp[i][0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
    # 综上，当 i = 0 或者 j = 0 时，dp[i][j] 初始化为 0
    #
    # 遍历方向与范围
    # 由于 dp[i][j] 依赖与 dp[i - 1][j - 1] , dp[i - 1][j], dp[i][j - 1]，所以 i 和 j 的遍历顺序肯定是从小到大的。
    # 另外，由于当 i 和 j 取值为 0 的时候，dp[i][j] = 0，而 dp 数组本身初始化就是为 0，所以，直接让 i 和 j 从 1 开始遍历。遍历的结束应该是字符串的长度为 len(text1)和len(text2)。
    #
    # 最终返回结果：
    # 由于 dp[i][j] 的含义是 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。我们最终希望求的是 text1 和 text2 的最长公共子序列。所以需要返回的结果是 i = len(text1) 并且 j = len(text2) 时的 dp[len(text1)][len(text2)]。
    # 
    # 复杂度分析
    # 时间复杂度：O(mn)，其中m和n分别是字符串text1和text2的长度。二维数组dp有m+1 行和n+1列，需要对dp中的每个元素进行计算。
    # 空间复杂度：O(mn)，其中m和n分别是字符串text1和text2的长度。创建了m+1行n+1列的二维数组dp。
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]
# @lc code=end

