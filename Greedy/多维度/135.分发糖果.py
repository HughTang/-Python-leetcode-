#
# @lc app=leetcode.cn id=135 lang=python3
#
# [135] 分发糖果
#

# @lc code=start
class Solution:
    # 题目分析：
    # 对于这个问题，主要的条件是要相邻孩子，得分高的拿的糖果要多（不包括相等得分），还有就是每个人最少都要有一个。
    # 解决这个问题我们还是采用贪心算法，首先初始化每个人分配的糖果数量都是1，然后这个算法需要遍历两遍，
    # 第一遍从左往右遍历，如果当前孩子的分数大于前一个孩子的分数，则当前孩子得到的糖果在前一个孩子的基础上加1；
    # 然后，第二遍从右往左遍历，如果当前孩子的分数大于他右边孩子的分数，并且他的糖果不比他右边孩子多，则糖果数在他基础上加1；
    # 最后，将所有孩子的糖果数相加即可。第二次遍历是为了处理数组中降序和有出现相邻孩子分数相同的情况。

    # 题解算法：
    # 典型的贪心算法题本身可以用贪心法来做，我们用candy[n]表示每个孩子的糖果数，遍历过程中，如果孩子i+1的rate大于孩子i的rate，
    # 那么当前最好的选择自然是：给孩子i+1的糖果数=给孩子i的糖果数+1；如果孩子i+1的rate小于等于孩子i 的rate咋整？这个时候就不大好办了，
    # 因为我们不知道当前最好的选择是给孩子i+1多少糖果。解决方法是：暂时不处理这种情况。等数组遍历完了，我们再一次从尾到头遍历数组，
    # 这回逆过来贪心，就可以处理之前略过的孩子。最后累加candy[n]即得到最小糖果数。
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        nums = [1] * n
        
        for i in range(1,n):
            if ratings[i] > ratings[i-1]:
                nums[i] = nums[i-1] + 1

        for i in reversed(range(n-1)):
            if ratings[i] > ratings[i+1] and nums[i] <= nums[i+1]:
                nums[i] = nums[i+1] + 1
        
        return sum(nums)
# @lc code=end

